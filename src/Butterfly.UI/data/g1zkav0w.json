{"modifiedDate":"2016-12-29 22:56:36","id":"g1zkav0w","title":"How to use Dynamic Proxy","abstract":"vcczz","creationDate":"2016-11-22T13:12:53.945Z","content":"<h3>​使用DynamicProxyInjectable标记动态代理类<\/h3><p>由于<code>DynamicProxyInjectable<\/code>继承于<code>DependencyInjectable<\/code>，因此它原生支持依赖注入，并且推荐使用依赖注入的方式生成代理类。通过查看<code>DynamicProxyAssemblyInfo<\/code>的实现可以看到，它在注册依赖注入时自动生成了动态代理类。<\/p><pre class=\"cs\">​[DynamicProxyInjectable(Inference = typeof(IBananaInterface), Singleton = true)]&#10;public class BananaClass : IBananaInterface&#10;{&#10;    \/\/ implement&#10;}<\/pre><h3>​使用IInterceptor编写拦截器<\/h3><p>拦截器类必须实现<code>IInterceptor<\/code>接口。由于动态代理使用依赖注入的方式查找拦截器，建议为每个拦截器声明各自的接口，然后再实现之。<\/p><pre class=\"cs\">​public interface ITimingInterceptor : IInterceptor<br\/>{<br\/>}<\/pre><p>下面定义的拦截器用于记录方法执行的总耗时。调用<code>invocation.Process()<\/code>执行被拦截的方法，其中<code>invocation<\/code>变量保存了方法的执行上下文，包括被拦截方法的传入参数值和方法的返回值。具体可以查看<code>IInvocation<\/code>接口提供的属性值。<\/p><pre class=\"cs\">​[DependencyInjectable(Inference = typeof(ITimingInterceptor), Singleton = true)]&#10;public class TimingInterceptor : ITimingInterceptor&#10;{&#10;    public void Intercept(IInvocation invocation)&#10;    {&#10;        var stopwatch = new Stopwatch();&#10;        stopwatch.Start();&#10;&#10;        invocation.Process(); \/\/ 执行被拦截的方法&#10;&#10;        stopwatch.Stop();&#10;        Debug.Print(&#34;method '{0}' cost {1}ms totally.&#34;, invocation.MethodInfo.Name, stopwatch.Elapsed.TotalMilliseconds);&#10;    }&#10;}<\/pre><h3>使用MethodInterceptor设置拦截器<\/h3><p>只有标记了<code>DynamicProxyInjectable<\/code>类中的方法才能被拦截，使用<code>MethodInterceptor<\/code>标记要被拦截的方法。另外，需要注意的是，必须将被拦截的方法定义为虚拟方法。例如下面的示例，使用<code>ITimingInterceptor<\/code>拦截器拦截<code>void F(int, int)<\/code>方法。<\/p><pre>​[DynamicProxyInjectable(Inference = typeof(IBananaInterface), Singleton = true)]&#10;public class BananaClass : IBananaInterface&#10;{&#10;    [MethodInterceptor(Type = typeof(ITimingInterceptor))]&#10;    public virtual int F(int a, int b)&#10;    {&#10;        return a + b;&#10;    }&#10;}<\/pre><h3>​注册动态代理类<\/h3><p>动态代理类的注册方法与依赖注入注册方法类似。<\/p><p>下面的代码将动态代理类注册到<code>BaseDirectoryAssemblyContainer<\/code>容器中。<\/p><pre class=\"cs\">​DependencyInjector.GetContainer&lt;BaseDirectoryAssemblyContainer&gt;()&#10;    .RegisterAssemblies&lt;DynamicProxyAssemblyInfo&gt;();<\/pre><h3>​获取动态代理类<\/h3><p>下面的代码展示了如何使用依赖注入的方式获取动态代理类对象。<\/p><pre class=\"cs\">​var childBananaClass = DependencyInjector.GetObject&lt;IBananaInterface&gt;();&#10;var result = childBananaClass.F(1, 2);<\/pre>"}